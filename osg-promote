#!/usr/bin/python
"""A package promotion script for OSG"""

import glob
import itertools
import re
import os
import shutil
import subprocess
import sys
import time
import urllib

from osgbuild import kojiinter
from osgbuild import utils
from osgbuild.utils import printf
from optparse import OptionParser


kwrap = None
ksession = None

valid_dvers = ["el5", "el6"]
valid_routes = {
    "testing": ["osg-development", "osg-testing"],
    "contrib": ["osg-development", "osg-contrib"],
    "release": ["osg-testing", "osg-prerelease"],
    "prerelease": ["osg-testing", "osg-prerelease"]}


def get_screen_columns():
    """Return the number of columns in the screen"""
    screen_columns = os.environ.get('COLUMNS')
    if not screen_columns:
        try:
            screen_columns = int(utils.backtick("stty size").split()[1])
        except:
            screen_columns = 80
    return screen_columns


def print_table(contents_by_dver):
    """Print a dict of lists in a table, with each list being a column"""
    screen_columns = get_screen_columns()
    field_width = int(screen_columns / len(contents_by_dver))
    columns = []
    for entry in sorted(contents_by_dver):
        columns.append([entry, '---'] + sorted(contents_by_dver[entry]))
    for columns_in_row in itertools.izip_longest(*columns, fillvalue=''):
        for col in columns_in_row:
            printf("%-*s", field_width, col, end='')
        printf("")


def parse_cmdline_args(argv):
    parser = OptionParser("""
    %prog TODO
""") # ^ TODO
    parser.add_option("-r", "--route", default=None)
    parser.add_option("-n", "--dry-run", action="store_true", default=False)
    parser.add_option("--el5", action="store_true", default=False)
    parser.add_option("--el6", action="store_true", default=False)
    parser.add_option("--ignore-rejects", dest="skip_rejects", action="store_false", default=True)
    parser.add_option("--output-format", "--of", default='old',
                      help="Valid output formats are: old, short, long, relnote, none")
    parser.add_option("--no-date", "--nodate", default=False, action="store_true",
                       help="Do not add the date to the output")
    parser.add_option("--regen", default=False, action="store_true", help="Regenerate repo(s) afterward")
    parser.add_option("-y", "--assume-yes", action="store_true", default=False)
    
    options, args = parser.parse_args(argv[1:])

    return (options, args)


def get_latest_build(package, tag):
    """Return the NVR of the latest build of a package in a tag, or None"""
    latest = utils.backtick(["koji", "-q", "list-tagged", "--latest", tag, package])
    if not latest:
        return None
    else:
        return latest.split()[0]


def split_nvr(build):
    """Split an NVR into a [Name, Version, Release] list"""
    match = re.match(r"(?P<name>.+)-(?P<version>[^-]+)-(?P<release>[^-]+)$", build)
    if match:
        return [match.group('name'), match.group('version'), match.group('release')]
    else:
        return []


def get_tagged_builds(tag):
    """Return a list of NVRs of all builds in a tag"""
    global ksession
    data = ksession.listTagged(tag)
    return [x['nvr'] for x in data]
    

def get_tagged_builds_latest(tag):
    """Return a list of NVRs of the latest builds of each package in a tag"""
    global ksession
    data = ksession.listTagged(tag, latest=True)
    return [x['nvr'] for x in data]


def get_tagged_packages(tag):
    """Return all package names in a tag"""
    global ksession
    data = ksession.listPackages(tagID=ksession.getTag(tag)['id'], inherited=True)
    return [x['package_name'] for x in data]
    

def get_tag(pattern, dver=None):
    """Return the name of a koji tag matching 'pattern' for 'dver'.
    For example, get_tag('development', 'el5') returns 'el5-osg-development'
    If 'dver' is None, then the dver is assumed to be part of 'pattern'.
    Raise an Exception if no matching tag is found.

    """
    def get_first(*args):
        return utils.backtick(["koji", "search", "tag"] + list(args)).split("\n")[0]
    if dver is None:
        tag = (get_first("--exact", pattern) or
               get_first("--regex", re.quote(pattern) + ".*"))
    else:
        tag = (get_first("--exact", "%s-%s" %
                         (dver, pattern)) or
               get_first("--exact", "%s-osg-%s" %
                         (dver, pattern)) or
               get_first("--regex", "%s-(osg-)?%s.*" %
                         (dver, re.quote(pattern))))
    if not tag:
        raise Exception("Can't find tag %s in koji" % pattern)
    return tag


def split_dver(build):
    """Split out the dver from the NVR of 'build'.
    For example, split_dver("foobar-1-1.osg.el5") returns
    ("foobar-1-1.osg", "el5")
    
    """
    pattern = re.compile(r".(el\d)$")
    removed = pattern.sub("", build)
    dver = pattern.search(build)
    if dver:
        dver = dver.group(1)
    return (removed, dver)


class Promoter(object):
    def __init__(self, dvers, route, skip_rejects=True):
        self.dvers = dvers
        self.promoted_packages = {}
        self.tag_pkg_args = {}
        self.from_tag_base, self.to_tag_base = valid_routes[route]
        self.rejects_distinct_latest = dict([(x, []) for x in dvers])
        self.rejects_missing_build = dict([(x, []) for x in dvers])
        self.skip_rejects = skip_rejects
        self.tagged_builds = {}
        #self.tagged_latest = {}
        self.tagged_packages = {}
        for dver in self.dvers:
            from_tag = get_tag(self.from_tag_base, dver)
            to_tag = get_tag(self.to_tag_base, dver)

            for tag in [from_tag, to_tag]:
                self.tagged_builds[tag] = get_tagged_builds(tag)
                #self.tagged_latest[tag] = get_tagged_builds_latest(from_tag)
                self.tagged_packages[tag] = [split_nvr(x)[0] for x in self.tagged_builds[tag]]


    def get_build_in_tag(self, tag, pkg_or_build):
        """Return the build matching 'pkg_or_build' in 'tag'.
        If pkg_or_build is not in the tag, returns None. Otherwise:
        If pkg_or_build is a package, returns the latest build for that
        package. If pkg_or_build is a build, it is returned unchanged.

        """
        if pkg_or_build in self.tagged_packages[tag]:
            return get_latest_build(pkg_or_build, tag)
        elif pkg_or_build in self.tagged_builds[tag]:
            return pkg_or_build
        else:
            return None
            
            
    def add_promotion(self, pkg_or_build):
        """See if 'pkg_or_build' can be promoted, add the build to
        self.tag_pkg_args for each tag it should be added to.
        
        """
        builds = self.get_builds(pkg_or_build, skip_rejects=self.skip_rejects)
        
        for dver in builds:
            to_tag = get_tag(self.to_tag_base, dver)
        
            build = builds[dver]
            self.tag_pkg_args.setdefault(to_tag, [])
            self.tag_pkg_args[to_tag].append(build)

        

    def get_builds(self, pkg_or_build, skip_rejects=False):
        """Get the builds keyed by dver for pkg_or_build."""
        builds = {}
        # find the build for each dver
        for dver in self.dvers:
            from_tag = get_tag(self.from_tag_base, dver)
            to_tag = get_tag(self.to_tag_base, dver)

            pkg_or_build_no_dver, _ = split_dver(pkg_or_build)
            build = self.get_build_in_tag(from_tag, pkg_or_build_no_dver + "." + dver) or self.get_build_in_tag(from_tag, pkg_or_build_no_dver)
            if not build:
                self.rejects_missing_build[dver].append(pkg_or_build_no_dver)
                if skip_rejects:
                    return []
                else:
                    continue
            builds[dver] = build

        if len(builds) == 0:
            return []
        # find builds where the nvrs (without dver) are distinct between the
        # dvers we are running the script for, and reject them.
        name = split_nvr(builds.values()[0])[0]
        vrs = ['-'.join(split_nvr(builds[x])[1:]) for x in builds]
        vrs_no_dver = [split_dver(x)[0] for x in vrs]
        if len(set(vrs_no_dver)) > 1:
            for dver in builds:
                self.rejects_distinct_latest[dver].append(builds[dver])
            if skip_rejects:
                return []
        return builds
        
    def tag_builds(self, dry_run=False, regen=False):
        global kwrap
        global ksession

        printf("--- Tagging builds")
        tags = set()
        tasks = dict()
        for tag, builds in self.tag_pkg_args.iteritems():
            tags.add(tag)
            for build in builds:
                try:
                    if build in self.tagged_builds[tag]:
                        printf("Skipping %s, already in %s", build, tag)
                        continue
                except: pass
                printf("tagBuild('%s', '%s')", tag, build)
                build_no_dver, dver = split_dver(build)
                dver = dver or ''
                err = False
                if not dry_run:
                    task_id = kwrap.tag_build(tag, build)
                    tasks[task_id] = (build_no_dver, dver, build)

        if not dry_run:
            kwrap.watch_tasks(list(tasks.keys()))
            for task_id in tasks:
                build_no_dver, dver, build = tasks[task_id]
                err = kojiinter.KojiLibInter.TASK_STATES[ksession.getTaskInfo(task_id)['state']] != 'CLOSED'
                if not err:
                    self.promoted_packages.setdefault(build_no_dver, dict())
                    self.promoted_packages[build_no_dver][dver] = build
                else:
                    printf("* Error promoting build %s", build)
        if regen:
            printf("--- Regenerating repos")
            for tag in tags:
                kwrap.watch_tasks([kwrap.regen_repo(tag)])


    def write_twiki(self, output_format, no_date=False, fh=None):
        if not fh:
            fh=sys.stdout
        def write_field(text):
            fh.write(text)
            if output_format == 'long':
                fh.write("\\\n")
        first = True
        if output_format == 'relnote':
            for dver in self.dvers:
                for build_no_dver in sorted(self.promoted_packages):
                    build = self.promoted_packages[build_no_dver][dver]
                    fh.write("   * [[%s][%s]]\n" % (get_build_uri(build), build))
        elif output_format == 'long' or output_format == 'short':
            for build_no_dver in sorted(self.promoted_packages):
                if first and not no_date:
                    write_field("| %s |" % time.strftime("%Y-%m-%d"))
                    first = False
                else:
                    write_field("| |")
                write_field(" %(build_no_dver)s |" % locals())
                for dver in sorted(self.promoted_packages[build_no_dver]):
                    build = self.promoted_packages[build_no_dver][dver]
                    write_field(" [[%s][%s]]" % (get_build_uri(build), dver))
                write_field(" | |\n")
        elif output_format == 'old':
            for build_no_dver in sorted(self.promoted_packages):
                if first and not no_date:
                    write_field("| %s |" % time.strftime("%Y-%m-%d"))
                    first = False
                else:
                    write_field("||")
                fh.write(" %(build_no_dver)s " % locals())
                builds = []
                for dver in sorted(self.promoted_packages[build_no_dver]):
                    build = self.promoted_packages[build_no_dver][dver]
                    builds += ["[[%s][%s]]" % (get_build_uri(build), dver)]
                fh.write("(" + "+".join(builds) + ")")
                write_field(" |\n")
        else:
            print "Unknown output format!"

        

#def get_search_uri(match, stype, terms):
#    quoted_args = [urllib.quote_plus(x) for x in [match, stype, terms]]
#    return ("https://koji-hub.batlab.org/koji/search?match=%s&type=%s&terms=%s" %
#            tuple(quoted_args))
#
#
#def get_exact_build_uri(build):
#    return get_search_uri('exact', 'build', build)
#
#
def get_build_uri(build):
    global ksession
    buildinfo = ksession.getBuild(build)
    return ("https://koji-hub.batlab.org/koji/buildinfo?buildID=%d" % int(buildinfo['id']))
    
    
    


def main(argv=None):
    global kwrap
    global ksession

    if argv is None:
        argv = sys.argv
    
    options, pkgs_or_builds = parse_cmdline_args(argv)


    # What dvers (e.g. el5) to promote for
    if not options.el5 and not options.el6:
        dvers = valid_dvers
    else:
        dvers = []
        if options.el5:
            dvers.append('el5')
        if options.el6:
            dvers.append('el6')

    
    # Promotion route
    if not options.route:
        raise Exception("Need route.")
    matching_routes = [x for x in valid_routes.keys() if x.startswith(options.route)]
    if len(matching_routes) > 1:
        raise Exception("Ambiguous route.")
    elif not matching_routes:
        raise Exception("Invalid route.")
    else:
        route = matching_routes[0]


    # Connect to koji-hub
    kwrap = kojiinter.KojiLibInter()
    kwrap.read_config_file()
    kwrap.init_koji_session(login=(not options.dry_run))
    ksession = kwrap.kojisession


    printf("Promoting from %s to %s for dvers: %s", valid_routes[route][0], valid_routes[route][1], ", ".join(dvers))
    printf("Examining the following packages/builds:\n%s", "\n".join(["'" + x + "'" for x in pkgs_or_builds]))

    promoter = Promoter(dvers, route, options.skip_rejects)
    for x in pkgs_or_builds:
        promoter.add_promotion(x)

    
    # Print rejects table
    rejects = False
    if any(promoter.rejects_distinct_latest.values()):
        rejects = True
        printf("*** rejects (latest versions for package different between dvers")
        print_table(promoter.rejects_distinct_latest)
    if any(promoter.rejects_missing_build.values()):
        rejects = True
        printf("*** rejects (builds missing for some dvers):")
        print_table(promoter.rejects_missing_build)

    print "Promotion plan:"
    if any(promoter.tag_pkg_args.values()):
        print_table(promoter.tag_pkg_args)
    else:
        printf("Nothing will be promoted!")
    
    question = "Proceed with promoting the builds?"
    if rejects:
        question += " Rejects will not be promoted!"
        return 1

    # Do the actual tagging
    if (options.assume_yes or (sys.stdin.isatty() and utils.ask_yn(question))):
        promoter.tag_builds(options.dry_run, options.regen)
        if options.output_format != 'none':
            printf("\nTwiki code for this set of promotions:\n")
            promoter.write_twiki(options.output_format, options.no_date)
    else:
        printf("Not proceeding.")
        return 1

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))

